import pandas as pd

def calculate_utility(p_jk, s_jk):
    """
    Calculate the utility value for a worker-order pair.
    :param p_jk: Estimated profit for worker k delivering order j.
    :param s_jk: Service time for worker k delivering order j.
    :return: Utility value (p_jk - s_jk).
    """
    return p_jk - s_jk

def is_valid_assignment(X, j, k, service_times, s_max):
    """
    Check if assigning order j to worker k is valid.
    :param X: Current assignment matrix.
    :param j: Order index.
    :param k: Worker index.
    :param service_times: DataFrame containing service times for each (order, worker) pair.
    :param s_max: Maximum allowable service time.
    :return: True if the assignment is valid, False otherwise.
    """
    # Check if the worker is already assigned to another order
    if any(X[j2][k] == 1 for j2 in X):
        return False

    # Check if the service time is within the allowable limit
    if service_times.at[(j, k), 'service_time'] > s_max:
        return False

    return True

def backtrack(X, orders, workers, service_times, estimated_profits, s_max, solutions, order_index=0):
    """
    Use backtracking to explore all possible assignments of orders to workers.
    :param X: Current assignment matrix.
    :param orders: List of orders.
    :param workers: List of workers.
    :param service_times: DataFrame containing service times for each (order, worker) pair.
    :param estimated_profits: DataFrame containing estimated profits for each (order, worker) pair.
    :param s_max: Maximum allowable service time.
    :param solutions: List to store all valid solutions.
    :param order_index: Current order index being processed.
    :return: None
    """
    # Base case: If all orders have been assigned, save the solution
    if order_index == len(orders):
        solutions.append({j: X[j].copy() for j in X})
        return

    # Get the current order to be assigned
    j = orders[order_index]

    # Try assigning the current order to each worker
    for k in workers:
        if is_valid_assignment(X, j, k, service_times, s_max):
            # Assign the order to the worker
            X[j][k] = 1

            # Recur to assign the next order
            backtrack(X, orders, workers, service_times, estimated_profits, s_max, solutions, order_index + 1)

            # Backtrack: Unassign the order from the worker
            X[j][k] = 0

def generate_all_feasible_solutions(orders, workers, service_times, estimated_profits, s_max):
    """
    Generate all possible feasible solutions where each worker can only handle one order at a time.
    :param orders: List of orders.
    :param workers: List of workers.
    :param service_times: DataFrame containing service times for each (order, worker) pair.
    :param estimated_profits: DataFrame containing estimated profits for each (order, worker) pair.
    :param s_max: Maximum allowable service time for any worker.
    :return: List of all feasible solutions.
    """
    # Initialize assignment matrix X[j][k] = 0 for all j ∈ J, k ∈ K
    X = {j: {k: 0 for k in workers} for j in orders}

    # List to store all feasible solutions
    solutions = []

    # Start the backtracking process to generate all feasible solutions
    backtrack(X, orders, workers, service_times, estimated_profits, s_max, solutions)

    return solutions

def flatten_solution(solution, orders, workers):
    """
    Flatten a solution matrix into a list of lists, each list representing a row.
    :param solution: Solution matrix as a dictionary of dictionaries.
    :param orders: List of orders.
    :param workers: List of workers.
    :return: Flattened list of lists representing the solution matrix.
    """
    flat_solution = []
    for j in orders:
        row = [solution[j][k] for k in workers]
        flat_solution.append(row)
    return flat_solution

def algorithm_2(orders_file, workers_file, service_times_file, estimated_profits_file, s_max, output_file):
    """
    Execute Algorithm 2 to generate all sets of initial feasible solutions and save them in a single CSV file.
    :param orders_file: Path to the orders data file (CSV).
    :param workers_file: Path to the workers data file (CSV).
    :param service_times_file: Path to the service times data file (CSV).
    :param estimated_profits_file: Path to the estimated profits data file (CSV).
    :param s_max: Maximum allowable service time for any worker.
    :param output_file: Path to the output CSV file.
    :return: None
    """
    try:
        # Load data from CSV files
        orders_df = pd.read_csv(orders_file)
        workers_df = pd.read_csv(workers_file)
        service_times = pd.read_csv(service_times_file, index_col=[0, 1])
        estimated_profits = pd.read_csv(estimated_profits_file, index_col=[0, 1])

        # Extract orders and workers as lists
        orders = orders_df['order_id'].tolist()
        workers = workers_df['worker_id'].tolist()

        # Generate all feasible solutions
        all_solutions = generate_all_feasible_solutions(orders, workers, service_times, estimated_profits, s_max)

        # Initialize the final DataFrame with the header
        columns = ['order_id'] + workers
        final_df = pd.DataFrame(columns=columns)

        # Populate the DataFrame with all solutions
        for solution in all_solutions:
            flattened = flatten_solution(solution, orders, workers)
            temp_df = pd.DataFrame(flattened, columns=workers)
            temp_df.insert(0, 'order_id', orders)
            final_df = pd.concat([final_df, temp_df], axis=0)

        # Save the final DataFrame to a CSV file
        final_df.to_csv(output_file, index=False)
        print(f"All feasible solutions saved to {output_file}.")
    except Exception as e:
        print(f"An error occurred: {e}")
        return None


# Define parameters
s_max = 6  # Maximum allowable service time

orders_file = r"D:\MASTER DEGREE IN GERMANY\0. STUDIUM\Semester 2\Seminar AI\Alg2\orders_file.csv"
workers_file = r"D:\MASTER DEGREE IN GERMANY\0. STUDIUM\Semester 2\Seminar AI\Alg2\workers_file.csv"
service_times_file = r"D:\MASTER DEGREE IN GERMANY\0. STUDIUM\Semester 2\Seminar AI\Alg2\service_times_file.csv"
estimated_profits_file = r"D:\MASTER DEGREE IN GERMANY\0. STUDIUM\Semester 2\Seminar AI\Alg2\estimated_profits_file.csv"
output_file = r"D:\MASTER DEGREE IN GERMANY\0. STUDIUM\Semester 2\Seminar AI\Alg2\all_feasible_solutions.csv"

# Run Algorithm 2 to generate and save all feasible solutions
algorithm_2(orders_file, workers_file, service_times_file, estimated_profits_file, s_max, output_file)
