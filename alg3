import random
import numpy as np

def fitness_function(X, profits, service_times, s_max, m, beta, estimated_times):
    """
    Calculate the fitness of a solution X based on the modified profit and service time.
    """
    total_profit = 0
    total_service_time = 0
    K_x = set()  # Set of workers with at least one assigned order
    
    for j, workers in X.items():
        for k, assigned in workers.items():
            if assigned == 1:
                K_x.add(k)
                # Calculate the actual service time
                s_jk = service_times[(j, k)]
                # Calculate the estimated service time
                s_tilde_jk = estimated_times[(j, k)]
                # Calculate the payment with the conditional bonus
                tau_jk = m[k] + beta * int(s_jk <= s_tilde_jk)
                # Calculate the profit
                p_jk = tau_jk - profits[(j, k)]
                total_profit += p_jk
                total_service_time += s_jk

    # Normalize service time and profit
    s_k = total_service_time / (len(X) * s_max)
    p_k = total_profit / sum([m[k] for k in K_x])
    
    if s_k > 1 or p_k < 0:  # Check constraints
        return -1  # Invalid solution

    return p_k - s_k  # Return the fitness value

def water_wave_optimization(J, K, s_max, m, profits, service_times, estimated_times, beta, P_size=10, max_iter=100):
    # Step 1: Generate an initial set of solutions P using Algorithm 2
    P = [initial_feasible_solution(J, K, s_max, m) for _ in range(P_size)]
    
    # Step 2: Select the best initial solution X* from P
    X_star = max(P, key=lambda X: fitness_function(X, profits, service_times, s_max, m, beta, estimated_times))
    
    iter = 0
    while iter <= max_iter:
        for X in P:
            # Step 6: Calculate Î»X for each X in P
            lambda_X = calculate_wavelength(X, P, profits, service_times, s_max, m)
            
            # Step 7: Determine the number of propagation steps W
            W = random.randint(1, int(lambda_X))
            
            # Step 8: Propagate X for W steps to generate X'
            X_prime = X.copy()
            for _ in range(W):
                j = random.choice(J)
                k = random.choice(K)
                X_prime = flip_assignment(X_prime, j, k)
            
            # Step 13: If X' is better than X, replace X with X' in P
            if fitness_function(X_prime, profits, service_times, s_max, m, beta, estimated_times) > fitness_function(X, profits, service_times, s_max, m, beta, estimated_times):
                P.remove(X)
                P.append(X_prime)
                
                # Step 15: If X' is better than X*, update X*
                if fitness_function(X_prime, profits, service_times, s_max, m, beta, estimated_times) > fitness_function(X_star, profits, service_times, s_max, m, beta, estimated_times):
                    X_star = X_prime
            
            # Step 18: Perform neighbourhood search around X*
            nb = random.randint(1, len(K))
            for _ in range(nb):
                X_n = X_star.copy()
                j = random.choice(J)
                k = random.choice(K)
                X_n = flip_assignment(X_n, j, k)
                
                # Step 23: If X_n is better than X*, update X*
                if fitness_function(X_n, profits, service_times, s_max, m, beta, estimated_times) > fitness_function(X_star, profits, service_times, s_max, m, beta, estimated_times):
                    X_star = X_n
        
        iter += 1
    
    # Step 30: Return the best solution X*
    return X_star

# Example usage
J = [1, 2, 3]  # Set of orders
K = ['worker1', 'worker2']  # Set of workers

s_max = 15  # Maximum allowable service time
m = {'worker1': 25, 'worker2': 20}  # Payment for each worker
beta = 5  # Bonus for on-time delivery

# Simulated profits, service times, and estimated service times (replace with actual data)
profits = {
    (1, 'worker1'): 20, (1, 'worker2'): 18,
    (2, 'worker1'): 22, (2, 'worker2'): 21,
    (3, 'worker1'): 19, (3, 'worker2'): 17,
}
service_times = {
    (1, 'worker1'): 10, (1, 'worker2'): 12,
    (2, 'worker1'): 8, (2, 'worker2'): 9,
    (3, 'worker1'): 15, (3, 'worker2'): 13,
}
estimated_times = {
    (1, 'worker1'): 11, (1, 'worker2'): 12,
    (2, 'worker1'): 9,  (2, 'worker2'): 10,
    (3, 'worker1'): 14, (3, 'worker2'): 13,
}

X_star = water_wave_optimization(J, K, s_max, m, profits, service_times, estimated_times, beta)

print("Optimal Assignment (X*):")
for j in J:
    for k in K:
        print(f"Order {j} assigned to {k}: {X_star[j][k]}")

